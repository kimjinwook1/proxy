**프록시의 주요 기능**
- 접근제어
  - 권한에 따른 접근 차단
  - 캐싱
  - 지연로딩
- 부가 기능 추가
  - 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.
  - 예) 요청 값이나 응답 값을 중간에 변형한다.
  - 예) 실행시간을 측정해서 추가 로그를 남긴다.

- 프록시 패턴 : 접근 제어가 목적
- 데코레이터 패턴 : 새로운 기능 추가가 목적

### 프록시 패턴 vs 데코레이터 패턴
**의도**
- 프록시 패턴과 데코레이터 패턴은 그 모양이 거의 같고, 상황에 따라 정말 똑같을 때도 있다. 
- 디자인 패턴에서 중요한 것은 해당 패턴의 겉모양이 아니라 그 패턴을 만든 **의도**가 더 중요하다.

- 프록시 패턴의 의도 : 다른 개체에 대한 **접근을 제어** 하기 위해 대리자를 제공
- 데코레이터 패턴의 의도 : **객체에 추가 책임(기능)을 동적으로 추가** 하고, 기능 확장을 위한 유연한 대안 제공

## 인터페이스 기반 프록시와 클래스 기반 프록시
**인터페이스 기반 프록시 vs 클래스 기반 프록시**
- 인터페이스가 없어도 클래스 기반으로 프록시를 생성할 수 있다.
- 클래스 기반 프록시는 해당 클래스에만 적용할 수 있다. 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용할 수 있다.
- 클래스 기반 프록시는 상속을 사용하기 때문에 몇 가지 제약이 있다.
  - 부모 클래스의 생성자를 호출해야 한다.
  - 클래스에 final 키워드가 붙으면 상속이 불가능하다.
  - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다.

- 결론  
실무에서는 프록시를 적용할 때 인터페이스가 있는 경우도 있고, 구체 클래스가 있는 경우도 있다. 두 가지 상황을 모두 대응할 수 있어야 한다.
